# III. Services

## 2. Analyser un service existant

On a d√©j√† install√© et lanc√© le *service* SSH normalement sur votre VM Debian, ce qui vous permet de vous connecter en SSH. On va se servir de lui pour regarder √† quoi ressemble un *service* d√©j√† install√© !

üåû **S'assurer que le service `ssh` est d√©marr√©**

- avec une commande `systemctl status`

> *Vous pouvez utiliser des commandes comme `sudo systemctl list-units -t service -a` pour lister tous les services de la machine. Voil√† pour le fun, si t'as envie de regarder un peu tout ce qu'il y a qui tourne. C'est litt√©ralement tous les constituants de l'OS que t'as sous les yeux si tu le fais, puisqu'on a ajout√© aucun service nous-m√™mes pour le moment, √† part le service SSH.*

CMD : 
```
systemctl status
```
REPONSE : 
```
‚óè TPOS
    State: running
    Units: 277 loaded (incl. loaded aliases)
     Jobs: 0 queued
   Failed: 0 units
    Since: Wed 2024-11-13 09:33:12 CET; 45min ago
  systemd: 252.30-1~deb12u2
   CGroup: /
           ‚îú‚îÄinit.scope
           ‚îÇ ‚îî‚îÄ1 /sbin/init
           ‚îú‚îÄsystem.slice
           ‚îÇ ‚îú‚îÄModemManager.service
           ‚îÇ ‚îÇ ‚îî‚îÄ498 /usr/sbin/ModemManager
           ‚îÇ ‚îú‚îÄNetworkManager.service
           ‚îÇ ‚îÇ ‚îî‚îÄ484 /usr/sbin/NetworkManager --no-daemon
           ‚îÇ ‚îú‚îÄavahi-daemon.service
           ‚îÇ ‚îÇ ‚îú‚îÄ464 "avahi-daemon: running [TPOS.local]"
           ‚îÇ ‚îÇ ‚îî‚îÄ479 "avahi-daemon: chroot helper"
           ‚îÇ ‚îú‚îÄcolord.service
           ‚îÇ ‚îÇ ‚îî‚îÄ926 /usr/libexec/colord
           ‚îÇ ‚îú‚îÄcron.service
           ‚îÇ ‚îÇ ‚îî‚îÄ465 /usr/sbin/cron -f
           ‚îÇ ‚îú‚îÄcups-browsed.service
           ‚îÇ ‚îÇ ‚îî‚îÄ634 /usr/sbin/cups-browsed
           ‚îÇ ‚îú‚îÄcups.service
           ‚îÇ ‚îÇ ‚îú‚îÄ632 /usr/sbin/cupsd -l
           ‚îÇ ‚îÇ ‚îî‚îÄ633 /usr/lib/cups/notifier/dbus dbus://
           ‚îÇ ‚îú‚îÄdbus.service
           ‚îÇ ‚îÇ ‚îî‚îÄ466 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --sysl>
 ESCOC
```
üåû **Isolez la ligne qui indique le nom du programme lanc√©**

- un *service* lanc√©, c'est juste un *programme* qui a √©t√© lanc√© pour nous pour rappel
- quand on fait un `systemctl start <SERVICE>`, l'OS lance juste une *commande* √† notre place
- quelle commande ? Dans le `systemctl status`, le nom et le PID du *programme* lanc√© sont indiqu√©s, isolez donc cette ligne

CMD : 
```
systemctl status ssh | grep 'Main PID'
```
REPONSE :
```
   Main PID: 617 (sshd)
```
üåû **D√©terminer le port sur lequel √©coute le service SSH**

- avec une commande `ss`, en ajoutant les options
  - `-l` pour *listen* : on affiche les programmes en √©coute
  - `-t` pour *tcp* : uniquement les ports TCP
  - `-p` pour *program* : on affiche le nom du programme qui √©coute
  - `-n` pour *numeric* : affichage des ports sous forme num√©rique
  - donc `sudo ss -lnpt` pour lister tous les *programmes* qui √©coutent sur le r√©seau et attendent la connexion de clients
- isolez les lignes int√©ressantes avec un `| grep <TEXTE>`

> Le service SSH √©coute par convention sur le port 22 en TCP. Vous devez donc voir une ligne qui indique une √©coute sur le port 22, par le programme `sshd`.

CMD :
```
sudo ss -lnpt | grep 'sshd'
```

REPONSE : 
```
LISTEN 0      128          0.0.0.0:22        0.0.0.0:*    users:(("sshd",pid=617,fd=3))
LISTEN 0      128             [::]:22           [::]:*    users:(("sshd",pid=617,fd=4))
```
üåû **Consulter les logs du service SSH**

- les logs du service sont consultables avec une commande `journalctl`
  - donnez une commande `journalctl` qui permet de consulter les logs du service SSH

CMD :
```
sudo journalctl -u ssh
```
REPONSE :
```
Nov 06 12:29:09 TPOS systemd[1]: Starting ssh.service - OpenBSD Secure Shell server...
Nov 06 12:29:10 TPOS sshd[542]: Server listening on 0.0.0.0 port 22.
Nov 06 12:29:10 TPOS sshd[542]: Server listening on :: port 22.
Nov 06 12:29:10 TPOS systemd[1]: Started ssh.service - OpenBSD Secure Shell server.
-- Boot c86e302faaf24998a06e3295e87e3d8e --
Nov 07 08:23:29 TPOS systemd[1]: Starting ssh.service - OpenBSD Secure Shell server...
Nov 07 08:23:29 TPOS sshd[541]: Server listening on 0.0.0.0 port 22.
Nov 07 08:23:29 TPOS sshd[541]: Server listening on :: port 22.
Nov 07 08:23:29 TPOS systemd[1]: Started ssh.service - OpenBSD Secure Shell server.
Nov 07 09:13:44 TPOS sshd[1559]: Connection reset by 192.168.8.1 port 50785 [preauth]
Nov 07 09:17:09 TPOS sshd[1569]: Invalid user emrep from 192.168.8.1 port 50788
Nov 07 09:17:27 TPOS sshd[1569]: pam_unix(sshd:auth): check pass; user unknown
Nov 07 09:17:27 TPOS sshd[1569]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rho>
Nov 07 09:17:29 TPOS sshd[1569]: Failed password for invalid user emrep from 192.168.8.1 port 50788 ssh2
Nov 07 09:17:51 TPOS sshd[1569]: pam_unix(sshd:auth): check pass; user unknown
Nov 07 09:17:53 TPOS sshd[1569]: Failed password for invalid user emrep from 192.168.8.1 port 50788 ssh2
Nov 07 09:18:52 TPOS sshd[1569]: pam_unix(sshd:auth): check pass; user unknown
Nov 07 09:18:54 TPOS sshd[1569]: Failed password for invalid user emrep from 192.168.8.1 port 50788 ssh2
Nov 07 09:18:54 TPOS sshd[1569]: Connection reset by invalid user emrep 192.168.8.1 port 50788 [preauth]
Nov 07 09:18:54 TPOS sshd[1569]: PAM 2 more authentication failures; logname= uid=0 euid=0 tty=ssh ruser= rhost=192.16>
Nov 07 09:23:04 TPOS sshd[1576]: Invalid user emrep from 192.168.8.1 port 50794
Nov 07 09:23:07 TPOS sshd[1576]: pam_unix(sshd:auth): check pass; user unknown
Nov 07 09:23:07 TPOS sshd[1576]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rho>
Nov 07 09:23:09 TPOS sshd[1576]: Failed password for invalid user emrep from 192.168.8.1 port 50794 ssh2
Nov 07 09:23:23 TPOS sshd[1576]: Connection reset by invalid user emrep 192.168.8.1 port 50794 [preauth]
Nov 07 09:23:34 TPOS sshd[1579]: Invalid user emrep from 192.168.8.1 port 50800
Nov 07 09:23:37 TPOS sshd[1579]: pam_unix(sshd:auth): check pass; user unknown
Nov 07 09:23:37 TPOS sshd[1579]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rho>
Nov 07 09:23:38 TPOS sshd[1579]: Failed password for invalid user emrep from 192.168.8.1 port 50800 ssh2
lines 1-29
```
## 3. Modification du service

### A. Configuration du service SSH

üåû **Identifier le fichier de configuration du serveur SSH**

- utilisez une commande pour voir le propri√©taire du fichier
- et les permissions appliqu√©es dessus

CMD a :
```
ls -l /etc/ssh/sshd_config
```
CMD :
```
-rw-r--r-- 1 root root 3223 Jun 22 21:38 /etc/ssh/sshd_config
```
üåû **Modifier le fichier de conf**

- ex√©cutez un `echo $RANDOM` dans votre shell pour **demander √† votre shell de vous fournir un nombre al√©atoire**
  - simplement pour vous montrer la petite astuce et vous faire manipuler le shell :)
  - pour un num√©ro de port valide, c'est entre 1 et 65535 ! 
- **changez le port d'√©coute du serveur SSH** pour qu'il √©coute sur ce num√©ro de port
  - il faut modifier le fichier de configuration avec `nano` par exemple, une seule ligne √† changer
  - dans le compte-rendu je veux un `cat` du fichier de conf
  - filtr√© par un `| grep` pour mettre en √©vidence la ligne que vous avez modifi√©

REPONSE :
```
echo $RANDOM
---
sudo nano /etc/ssh/sshd_config
---
#Port 27672
---
cat /etc/ssh/sshd_config | grep 'Port'
```
CMD :
```
27672
---
#Port 27672
#GatewayPorts no
```

üåû **Red√©marrer le service**

- avec une *commande* `systemctl restart <SERVICE>`

> **C'est TOUT LE TEMPS comme √ßa :** quand vous modifiez la configuration d'un truc, **il faut relancer le truc pour que la configuration prenne effet.** Logique, puisque c'est au d√©marrage qu'un *programme* regarde la configuration qu'il doit adopter.

REPONSE :
```
sudo systemctl restart ssh
```

üåû **Effectuer une connexion SSH sur le nouveau port**

- depuis votre PC
- il faudra utiliser une option √† la *commande* `ssh` pour vous connecter √† la VM afin de pr√©ciser un port non-conventionnel (celui que vous avez d√©fini dans le *fichier de configuration*)

REPONSE :
```
ssh -p 27672 senkai@192.168.8.7
```

### B. Le service en lui-m√™me

Il existe un fichier qui d√©finit quoi faire quand on tape `systemctl start ssh`. En effet, taper une *commande* `systemctl start` revient juste √† demander √† l'OS de lancer un *service* : c'est √† dire un simple *programme* lanc√©.

Quel *programme* ? Il existe un fichier qui porte l'extension `.service` qui d√©finit (entre autres), pour chaque *service*, quelle est le *programme* √† lancer.

üåû **Trouver le fichier `ssh.service`**

REPONSE : 
```
systemctl status ssh
---
sudo find / -name ssh.service
```
CMD :
```
‚óè ssh.service - OpenBSD Secure Shell server
     Loaded: loaded (/lib/systemd/system/ssh.service; enabled; preset: enabled)
     Active: active (running) since Wed 2024-11-13 10:32:15 CET; 8min ago
       Docs: man:sshd(8)
             man:sshd_config(5)
    Process: 1849 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS)
   Main PID: 1850 (sshd)
      Tasks: 1 (limit: 2284)
     Memory: 3.1M
        CPU: 94ms
     CGroup: /system.slice/ssh.service
             ‚îî‚îÄ1850 "sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"
---
/usr/lib/systemd/system/ssh.service            
```
üåû **D√©terminer quel est le programme lanc√©**

- quand on tape une commande `systemctl start ssh`, le fichier `ssh.service` est lu, et le *programme* indiqu√© en face de `ExecStart=` est lanc√©
- isolez uniquement cette ligne

```
senkai@TPOS:~$ grep 'ExecStart=' /lib/systemd/system/ssh.service
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
```
## 4. Cr√©ez votre propre service

‚ûú On va se servir d'une petite commande pratique pour mettre √ßa en oeuvre, faites un petit test d'abord :

- depuis un terminal de la VM :

```bash
# on cr√©e un ptit fichier bidon dans le dossier actuel
echo "meow" > meow

# on lance un ptit serveur web en une seule ligne de commande
# ptite commande python qui fait l'taf !
python3 -m http.server 8888

# vous pouvez couper la commande avec CTRL + C quand vous aurez fait le test juste apr√®s
```

- pendant que √ßa tourne, ouvrez un navigateur sur VOTRE PC
  - et visitez l'URL `http://<IP_VM>:8888`
  - par exemple `http://10.1.1.10:8888` si ta VM porte l'adresse IP 10.1.1.10
- √ßa doit fonctionner avant de continuer
  - vous devriez au moins voir le fichier `meow`

‚ûú Plut√¥t que de lancer cette commande √† la main pour avoir notre ptit serveur Web, on va cr√©er un service qui lance automatiquement cette commande !

üåû **D√©terminer le dossier qui contient la commande `python3`**

- avec une commande adapt√©e

```
senkai@TPOS:~$ which python3
/usr/bin/python3
```

üåû **Cr√©ez un fichier `/etc/systemd/system/meow_web.service`**

- avec `nano`, quand on modifie un fichier qui n'existe pas, il sera cr√©√©
- d√©posez le contenu suivant :

```
senkai@TPOS:~$ nano /etc/systemd/system/meow_web.service
senkai@TPOS:~$ sudo !!
```

üåû **Indiquez √† l'OS que vous avez modifi√© les *services***

```
senkai@TPOS:~$ systemctl daemon-reload
```
üåû **D√©marrez votre service**
```
senkai@TPOS:~$ systemctl start meow_web
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-units ====
Authentication is required to start 'meow_web.service'.
Authenticating as: senkai,,, (utsu)
Password:
==== AUTHENTICATION COMPLETE ====
```

üåû **Assurez-vous que le service `meow_web` est actif**
```
==== AUTHENTICATION COMPLETE ====
senkai@TPOS:~$ systemctl status meow_web
‚óè meow_web.service - Super serveur web MEOW
     Loaded: loaded (/etc/systemd/system/meow_web.service; disabled; pr>
     Active: active (running) since Wed 2024-11-13 10:19:58 CET; 19s ago
   Main PID: 3590 (python3)
      Tasks: 1 (limit: 2284)
     Memory: 8.9M
        CPU: 133ms
     CGroup: /system.slice/meow_web.service
             ‚îî‚îÄ3590 /usr/bin/python3 -m http.server 8888

```
üåû **D√©terminer le PID du *processus* Python en cours d'ex√©cution**
```
senkai@TPOS:~$ ps -eo pid,user,cmd | grep 'python3 -m http.server' | grep -v grep
   3590 root     /usr/bin/python3 -m http.server 8888
```
üåû **Prouvez que le *programme* √©coute derri√®re le port 8888**
```
senkai@TPOS:~$ sudo ss -tlp | grep ':8888'
LISTEN 0      5            0.0.0.0:8888       0.0.0.0:*    users:(("python3",pid=3590,fd=3))
```

üåû **Faire en sote que le *service* se lance automatiquement au d√©marrage de la machine**
```
senkai@TPOS:~$ systemctl enable meow_web
==== AUTHENTICATING FOR org.freedesktop.systemd1.manage-unit-files ====
Authentication is required to manage system service or unit files.
Authenticating as: senkai ,,, (senkai)
Password:
==== AUTHENTICATION COMPLETE ====
==== AUTHENTICATING FOR org.freedesktop.systemd1.reload-daemon ====
Authentication is required to reload the systemd state.
Authenticating as: senkai ,,, (senkai)
Password:
==== AUTHENTICATION COMPLETE ====
```